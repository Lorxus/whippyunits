use crate::quantity_type::{Quantity, Scale, Dimension, _2, _3, _5, _Pi, _M, _L, _T, _I, _Θ, _N, _J, _A};

// Generated by proc macro - covers range -20 to 20
whippyunits_proc_macros::pow_lookup!(pow2, 2, 20, rational);

// Generated by proc macro - covers range -15 to 15
whippyunits_proc_macros::pow_lookup!(pow3, 3, 15, rational);

// Generated by proc macro - covers range -10 to 10
whippyunits_proc_macros::pow_lookup!(pow5, 5, 10, rational);

// Generated by proc macro - covers range -8 to 8 using rational approximation 355/113
whippyunits_proc_macros::pow_pi_lookup!(pow_pi, 8, rational);

// Float lookup tables for const evaluation - generated by proc macro
whippyunits_proc_macros::pow_lookup!(pow2_float, 2.0, 20, float);

whippyunits_proc_macros::pow_lookup!(pow3_float, 3.0, 15, float);

whippyunits_proc_macros::pow_lookup!(pow5_float, 5.0, 10, float);

whippyunits_proc_macros::pow_pi_lookup!(pow_pi_float, 8, float);

#[macro_export]
macro_rules! define_aggregate_scale_factor_rational {
    (
        ($($aggregate_scale_factor_params:tt)*),
        ($($aggregate_scale_factor_diff_exprs:tt)*),
        ($($aggregate_scale_factor_pow_exprs:tt)*),
        ($($aggregate_scale_factor_num_exprs:tt)*),
        ($($aggregate_scale_factor_den_exprs:tt)*),
    ) => {
        pub const fn aggregate_scale_factor(
            $($aggregate_scale_factor_params)*
        ) -> (i128, i128) {
            $($aggregate_scale_factor_diff_exprs)*

            $($aggregate_scale_factor_pow_exprs)*

            reduce_rational($($aggregate_scale_factor_num_exprs)*, $($aggregate_scale_factor_den_exprs)*)
        }
    }
}

#[macro_export]
macro_rules! define_aggregate_scale_factor_float {
    (
        ($($aggregate_scale_factor_params:tt)*),
        ($($aggregate_scale_factor_diff_exprs:tt)*),
        ($($aggregate_scale_factor_pow_exprs:tt)*),
        ($($aggregate_scale_factor_expr:tt)*),
    ) => {
        pub const fn aggregate_scale_factor_float(
            $($aggregate_scale_factor_params)*
        ) -> f64 {
            $($aggregate_scale_factor_diff_exprs)*

            $($aggregate_scale_factor_pow_exprs)*

            $($aggregate_scale_factor_expr)*
        }
    }
}

/// Reduce a rational number to its simplest form using bit-shift based GCD
/// Returns (reduced_numerator, reduced_denominator)
pub const fn reduce_rational(num: i128, den: i128) -> (i128, i128) {
    if den == 0 {
        return (num, 1);
    }
    if num == 0 {
        return (0, 1);
    }

    // Convert to unsigned for bit operations
    let mut num_u = num.unsigned_abs();
    let mut den_u = den.unsigned_abs();

    // Remove common factors of 2 using bit shifts
    let common_twos = (num_u | den_u).trailing_zeros();
    num_u >>= common_twos;
    den_u >>= common_twos;

    // Now both are odd, so we can use the odd-odd case of binary GCD
    while num_u != den_u {
        if num_u > den_u {
            // num_u and den_u are both odd, so (num_u - den_u) is even
            let diff = num_u - den_u;
            num_u = diff >> diff.trailing_zeros(); // Remove factors of 2
        } else {
            let diff = den_u - num_u;
            den_u = diff >> diff.trailing_zeros(); // Remove factors of 2
        }
    }

    // num_u == den_u now, and both are odd, so this is the GCD
    let gcd = num_u;

    // Divide both by the GCD to get reduced form
    let reduced_num = num / (gcd as i128);
    let reduced_den = den / (gcd as i128);

    (reduced_num, reduced_den)
}

#[macro_export]
macro_rules! _define_float_rescale {
    (
        ($($float_rescale_const_params:tt)*),
        ($($float_rescale_input_type:tt)*),
        ($($float_rescale_output_type:tt)*),
        ($($float_rescale_aggregate_args:tt)*),
        $fn:ident, $T:ty,
    ) => {
        #[rustfmt::skip]
        pub const fn $fn<
            $($float_rescale_const_params)*
        > (
            quantity: $($float_rescale_input_type)*,
        ) -> $($float_rescale_output_type)* {
            let rescale_factor = aggregate_scale_factor_float(
                $($float_rescale_aggregate_args)*
            ) as $T;
            Quantity::<Scale<_2<SCALE_P2_TO>, _3<SCALE_P3_TO>, _5<SCALE_P5_TO>, _Pi<SCALE_PI_TO>>, Dimension<_M<MASS_EXPONENT>, _L<LENGTH_EXPONENT>, _T<TIME_EXPONENT>, _I<CURRENT_EXPONENT>, _Θ<TEMPERATURE_EXPONENT>, _N<AMOUNT_EXPONENT>, _J<LUMINOSITY_EXPONENT>, _A<ANGLE_EXPONENT>>, $T>::new(
                quantity.unsafe_value * rescale_factor
            )
        }
    };
}

#[macro_export]
macro_rules! _define_int_rescale {
    (
        ($($int_rescale_const_params:tt)*),
        ($($int_rescale_input_type:tt)*),
        ($($int_rescale_output_type:tt)*),
        ($($int_rescale_aggregate_args:tt)*),
        $fn:ident, $T:ty,
    ) => {
        #[rustfmt::skip]
        pub const fn $fn<
            $($int_rescale_const_params)*
        > (
            quantity: $($int_rescale_input_type)*,
        ) -> $($int_rescale_output_type)* {
            let (num, den) = aggregate_scale_factor(
                $($int_rescale_aggregate_args)*
            );
            let num = num as $T;
            let den = den as $T;

            // Numerical stability: check for potential overflow on multiplication
            // If value * num would overflow, divide first; otherwise multiply first
            let result = if quantity.unsafe_value > <$T>::max_value() / num {
                // Potential overflow: divide first to reduce intermediate value
                (quantity.unsafe_value / den) * num
            } else {
                // Safe to multiply first
                (quantity.unsafe_value * num) / den
            };

            Quantity::<Scale<_2<SCALE_P2_TO>, _3<SCALE_P3_TO>, _5<SCALE_P5_TO>, _Pi<SCALE_PI_TO>>, Dimension<_M<MASS_EXPONENT>, _L<LENGTH_EXPONENT>, _T<TIME_EXPONENT>, _I<CURRENT_EXPONENT>, _Θ<TEMPERATURE_EXPONENT>, _N<AMOUNT_EXPONENT>, _J<LUMINOSITY_EXPONENT>, _A<ANGLE_EXPONENT>>, $T>::new(result)
        }
    }
}
