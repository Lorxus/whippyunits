#![cfg_attr(not(feature = "std"), no_std)]
#![feature(generic_const_exprs)]
#![feature(trait_alias)]

#[cfg(not(feature = "std"))]
extern crate alloc;

// ============================================================================
// Core Types and Enums
// ============================================================================

pub trait IsI16<const S: i16> {}
impl<const S: i16> IsI16<S> for () {}

// #[macro_use]
// pub mod arithmetic_quantity_types;
pub mod arithmetic_quantity_types;
pub mod default_declarators;
pub mod imperial_declarators;
pub mod scale_conversion;
pub mod scoped_preferences;
// #[macro_use]
// pub mod quantity_type;
pub mod arithmetic;
pub mod dimension_traits;
pub mod print;
pub mod quantity_type;
// #[macro_use]
// pub mod api;
pub mod api;
pub mod custom_literals;
pub mod serialization;

// Custom literals are now generated by the whippy_literals proc macro

// Re-export macros that need to be available at crate root
pub use scoped_preferences::*;

// Re-export the new quantity type structure
pub use quantity_type::{Scale, Dimension, _2, _3, _5, _Pi, _M, _L, _T, _I, _Θ, _N, _J, _A};

// Re-export the proc macros for consumers to use
pub use whippyunits_proc_macros::define_generic_dimension;
pub use whippyunits_proc_macros::define_literals;
pub use whippyunits_proc_macros::local_unit_type;
pub use whippyunits_proc_macros::proc_unit as unit;
pub use whippyunits_proc_macros::whippy_literals;
pub use whippyunits_proc_macros::generate_scoped_preferences;

// from_json, from_string, from_json_strict, and from_string_strict macros are exported via #[macro_export] in serialization.rs

/// Unit-safe value extraction macro
/// 
/// Usage: `value!(quantity, unit_literal)`
/// 
/// This macro extracts the raw value from a quantity, rescaling it to the specified unit.
/// It's unit-safe because it uses the rescale function to ensure dimensional consistency.
/// The conversion is done statically at compile time using the type system.
/// 
/// Examples:
/// ```rust
/// let distance = quantity!(1, m);
/// let val: f64 = value!(distance, m);  // 1.0
/// let val: f64 = value!(distance, mm); // 1000.0
/// ```
#[macro_export]
macro_rules! value {
    ($quantity:expr, $unit:expr) => {{
        // Get the dimensions of the target unit at compile time
        const TARGET_DIMENSIONS: (i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16, i16) =
            whippyunits_proc_macros::compute_unit_dimensions!($unit);
        
        // Create a target quantity type
        type TargetQuantity = $crate::quantity_type::Quantity<
            $crate::quantity_type::Scale<
                $crate::quantity_type::_2<{ TARGET_DIMENSIONS.8 }>,
                $crate::quantity_type::_3<{ TARGET_DIMENSIONS.9 }>,
                $crate::quantity_type::_5<{ TARGET_DIMENSIONS.10 }>,
                $crate::quantity_type::_Pi<{ TARGET_DIMENSIONS.11 }>
            >,
            $crate::quantity_type::Dimension<
                $crate::quantity_type::_M<{ TARGET_DIMENSIONS.0 }>,
                $crate::quantity_type::_L<{ TARGET_DIMENSIONS.1 }>,
                $crate::quantity_type::_T<{ TARGET_DIMENSIONS.2 }>,
                $crate::quantity_type::_I<{ TARGET_DIMENSIONS.3 }>,
                $crate::quantity_type::_Θ<{ TARGET_DIMENSIONS.4 }>,
                $crate::quantity_type::_N<{ TARGET_DIMENSIONS.5 }>,
                $crate::quantity_type::_J<{ TARGET_DIMENSIONS.6 }>,
                $crate::quantity_type::_A<{ TARGET_DIMENSIONS.7 }>
            >,
            f64
        >;
        
        // Use rescale with type annotation - the compiler infers FROM parameters from input quantity type
        let rescaled: TargetQuantity = $crate::api::rescale($quantity);
        rescaled.value
    }};
}
