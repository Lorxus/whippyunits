import { spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export interface MacroExpansionResult {
    success: boolean;
    expandedType?: string;
    error?: string;
}

export class MacroExpander {
    private tempDir: string;
    public projectDir: string;

    constructor() {
        this.tempDir = os.tmpdir();
        // Find the whippyunits project directory (go up from current directory)
        this.projectDir = this.findWhippyUnitsProject();
    }

    /**
     * Expands a unit! macro using rustc
     * @param macroText The unit! macro text (e.g., "unit!(m)")
     * @returns The expanded type or error information
     */
    async expandUnitMacro(macroText: string): Promise<MacroExpansionResult> {
        // Clean the macro text - remove extra whitespace
        const cleanMacro = macroText.trim();
        
        if (!cleanMacro.startsWith('unit!')) {
            return {
                success: false,
                error: 'Text does not start with unit!'
            };
        }

        // Create a unique temporary directory for the project
        const tempDirName = `unit_macro_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const tempDir = path.join(this.tempDir, tempDirName);
        const srcDir = path.join(tempDir, 'src');
        const tempCargoToml = path.join(tempDir, 'Cargo.toml');
        const tempMainRs = path.join(srcDir, 'main.rs');
        
        try {
            // Generate a minimal Rust program that uses the unit! macro
            const rustCode = this.generateTestProgram(cleanMacro);
            const cargoTomlContent = this.generateCargoToml();
            
            // Create the project directory structure
            fs.mkdirSync(srcDir, { recursive: true });
            
            // Write the temporary files
            fs.writeFileSync(tempMainRs, rustCode);
            fs.writeFileSync(tempCargoToml, cargoTomlContent);
            
            // Also create a rust-toolchain.toml to ensure nightly is used
            const rustToolchainContent = `[toolchain]
channel = "nightly"
components = ["rustfmt", "clippy"]
`;
            fs.writeFileSync(path.join(tempDir, 'rust-toolchain.toml'), rustToolchainContent);
            
            // Copy the .cargo/config.toml to ensure the same rustc is used
            const cargoConfigPath = path.join(this.projectDir, '.cargo', 'config.toml');
            if (fs.existsSync(cargoConfigPath)) {
                const cargoConfigContent = fs.readFileSync(cargoConfigPath, 'utf8');
                const tempCargoDir = path.join(tempDir, '.cargo');
                fs.mkdirSync(tempCargoDir, { recursive: true });
                fs.writeFileSync(path.join(tempCargoDir, 'config.toml'), cargoConfigContent);
            }
            


            // Try to expand using cargo with the temp project
            const result = await this.expandWithRustc(tempDir, cleanMacro);
            
            return result;
        } catch (error) {
            return {
                success: false,
                error: `Failed to expand macro: ${error}`
            };
        } finally {
            // Clean up the temporary directory
            this.cleanupTempDir(tempDir);
        }
    }

    private generateTestProgram(macroText: string): string {
        return `#![feature(generic_const_exprs)]

// This is a temporary file generated by the WhippyUnits refactor extension
// It's used to expand unit! macros using rustc

// Include the whippyunits crate from the current workspace
use whippyunits::*;

fn main() {
    // Use the macro in a type annotation to force expansion
    let _test: ${macroText} = ();
    
    // Also try in a function signature
    fn test_function() -> ${macroText} {
        ()
    }
}
`;
    }

    private generateCargoToml(): string {
        return `[package]
name = "unit_macro_test"
version = "0.1.0"
edition = "2021"

[dependencies]
whippyunits = { path = "${this.projectDir}" }
`;
    }

    private async expandWithRustc(tempDir: string, originalMacro: string): Promise<MacroExpansionResult> {
        return new Promise((resolve) => {
            // Use rustup to run cargo with nightly toolchain to expand the macro
            const cargo = spawn('rustup', [
                'run',
                'nightly',
                'cargo',
                'rustc',
                '--',
                '-Z',
                'unpretty=expanded'
            ], {
                cwd: tempDir, // Use the temp directory where Cargo.toml is
                stdio: ['pipe', 'pipe', 'pipe']
            });

            let stdout = '';
            let stderr = '';

            cargo.stdout.on('data', (data) => {
                stdout += data.toString();
            });

            cargo.stderr.on('data', (data) => {
                stderr += data.toString();
            });

            cargo.on('close', (code) => {
                console.log(`Cargo command exited with code ${code}`);
                console.log(`Cargo stdout length: ${stdout.length}`);
                console.log(`Cargo stderr length: ${stderr.length}`);
                console.log(`Cargo stdout preview: ${stdout.substring(0, 1000)}...`);
                
                if (code !== 0) {
                    console.log(`Cargo failed, falling back to rustc method`);
                    // If cargo failed, try a different approach
                    this.tryAlternativeExpansion(path.join(tempDir, 'src', 'main.rs'), originalMacro).then(resolve);
                    return;
                }

                // Parse the expanded output
                const expandedType = this.extractExpandedType(stdout, originalMacro);
                
                if (expandedType) {
                    resolve({
                        success: true,
                        expandedType: expandedType
                    });
                } else {
                    resolve({
                        success: false,
                        error: 'Could not extract expanded type from cargo output'
                    });
                }
            });

            cargo.on('error', (error) => {
                resolve({
                    success: false,
                    error: `Failed to run cargo: ${error.message}`
                });
            });
        });
    }

    private async tryAlternativeExpansion(tempFile: string, originalMacro: string): Promise<MacroExpansionResult> {
        return new Promise((resolve) => {
            // Try with rustup nightly and expanded output instead
            const rustc = spawn('rustup', [
                'run',
                'nightly',
                'rustc',
                '--edition=2021',
                '-Z',
                'unpretty=expanded',
                tempFile
            ], {
                cwd: this.projectDir, // Use project directory so rustc can find whippyunits
                stdio: ['pipe', 'pipe', 'pipe']
            });

            let stdout = '';
            let stderr = '';

            rustc.stdout.on('data', (data) => {
                stdout += data.toString();
            });

            rustc.stderr.on('data', (data) => {
                stderr += data.toString();
            });

            rustc.on('close', (code) => {
                if (code !== 0) {
                    resolve({
                        success: false,
                        error: `rustc failed with exit code ${code}: ${stderr}`
                    });
                    return;
                }

                // Parse the expanded output
                const expandedType = this.extractExpandedType(stdout, originalMacro);
                
                if (expandedType) {
                    resolve({
                        success: true,
                        expandedType: expandedType
                    });
                } else {
                    resolve({
                        success: false,
                        error: 'Could not extract expanded type from rustc output'
                    });
                }
            });

            rustc.on('error', (error) => {
                resolve({
                    success: false,
                    error: `Failed to run rustc: ${error.message}`
                });
            });
        });
    }

    private extractExpandedType(expandedOutput: string, originalMacro: string): string | null {
        const lines = expandedOutput.split('\n');
        
        // Look for expanded Quantity types in the output
        for (const line of lines) {
            // Look for the expanded Quantity type with crate prefix
            if (line.includes('crate::Quantity<')) {
                const match = line.match(/crate::Quantity<[^>]+>/);
                if (match) {
                    return match[0];
                }
            }
            
            // Also look for just "Quantity<" in case the crate name is different
            if (line.includes('Quantity<')) {
                const match = line.match(/Quantity<[^>]+>/);
                if (match) {
                    return match[0];
                }
            }
        }
        
        return null;
    }



    private findWhippyUnitsProject(): string {
        // Start from current directory and look for Cargo.toml with whippyunits
        let currentDir = process.cwd();
        
        // Go up directories looking for the whippyunits project
        while (currentDir !== path.dirname(currentDir)) {
            const cargoTomlPath = path.join(currentDir, 'Cargo.toml');
            if (fs.existsSync(cargoTomlPath)) {
                const cargoContent = fs.readFileSync(cargoTomlPath, 'utf8');
                if (cargoContent.includes('name = "whippyunits"')) {
                    return currentDir;
                }
            }
            currentDir = path.dirname(currentDir);
        }
        
        // If not found, return current directory as fallback
        return process.cwd();
    }

    private cleanupTempDir(tempDir: string): void {
        try {
            if (fs.existsSync(tempDir)) {
                // Remove the entire directory recursively
                fs.rmSync(tempDir, { recursive: true, force: true });
            }
        } catch (error) {
            // Ignore cleanup errors
            console.warn(`Failed to cleanup temp directory ${tempDir}:`, error);
        }
    }

    private cleanupTempFile(tempFile: string): void {
        try {
            if (fs.existsSync(tempFile)) {
                fs.unlinkSync(tempFile);
            }
        } catch (error) {
            // Ignore cleanup errors
            console.warn(`Failed to cleanup temp file ${tempFile}:`, error);
        }
    }
}
